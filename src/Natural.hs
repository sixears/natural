{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE UnicodeSyntax              #-}

{-| Operations and support for natural numbers, including versions of `length`,
   `replicate`, etc.; also related support for unsigned values in general; and
   some type-level natural numbers -}

module Natural
  ( Abs(abs, abs', abs'')
  , AtMost(Cons, Nil)
  , Countable(count)
  , Four
  , I64
  , Length(len, len_, length, ‚Ñì, —â, ·ªª)
  , Nat(S, Z)
  , Natty(Sy, Zy)
  , None
  , NumSign(..)
  , One
  , Three
  , Two
  , ‚Ñï
  , atMost
  , atMostOne
  , atMostTwo
  , four
  , natNeg
  , none
  , one
  , propOpBounded
  , propOpRespectsBounds
  , three
  , two
  , unNegate
  , zeroOneOrTwo
  , (‚äï)
  , (‚äñ)
  , (‚äû)
  , (‚äü)
  , (‚ä†)
  , (‚®π)
  , (‚®∫)
  , (‚®ª)
  ) where

import Base0T hiding ( abs, (√∑), (‚äï) )
import Base0T qualified

import GHC.Enum ( Bounded, maxBound )
import GHC.Num  ( Num )
import GHC.Real ( Integral, Real, divMod, fromIntegral, toRational )

-- base --------------------------------

import Data.Foldable qualified
import Prelude qualified

import Control.Applicative ( Alternative )
import Data.Bits           ( FiniteBits(finiteBitSize), countLeadingZeros,
                             oneBits, testBit, xor, (.&.), (.<<.), (.>>.) )
import Data.Either         ( isLeft )
import Data.Foldable       ( Foldable )
import Data.Int            ( Int16, Int32, Int64, Int8 )
import Data.Kind           ( Type )
import Data.List           ( zip )
import Data.Ord            ( Ordering(EQ, GT, LT) )
import Data.Ratio          ( Ratio, denominator, numerator )
import Data.Tuple          ( uncurry )
import Data.Typeable       ( typeOf )
import Prelude             ( error )

-- base-unicode-symbols ----------------

import Prelude.Unicode ( (√ó) )

-- bytestring --------------------------

import Data.ByteString      qualified as BS
import Data.ByteString.Lazy qualified as BSL

-- lens --------------------------------

import Control.Lens.Setter    ( over )
import Control.Lens.Traversal ( both )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative ( (‚à§), (‚äµ) )
import Data.MoreUnicode.Bool        ( ùîπ, pattern ùìï, pattern ùì£ )
import Data.MoreUnicode.Either      ( ùîº, pattern ùìõ, pattern ùì° )
import Data.MoreUnicode.Functor     ( (‚ä≥) )
import Data.MoreUnicode.Maybe       ( pattern ùìô, ‚Öé )
import Data.MoreUnicode.Monoid      ( —é )
import Data.MoreUnicode.Num         ( (√∑) )
import Data.MoreUnicode.Ord         ( (‚â∂), (‚â∑) )
import Data.MoreUnicode.Semigroup   ( (‚óá) )
import Data.MoreUnicode.Text        ( ùïã )

-- tasty-quickcheck --------------------

import Test.Tasty.QuickCheck ( Property, property, (===) )

-- text --------------------------------

import Data.Text      qualified as Text
import Data.Text.Lazy qualified as LazyText

-- while -------------------------------

import While ( dropWhile )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Natural.BoundedError ( AsBoundedError,
                              BEType(LowerBoundType, UpperBoundType),
                              BoundedError, bound, boundedErrorType,
                              throwLowerBoundError, throwUpperBoundError )
import Natural.Unsigned     ( I64, Unsigned(boundMax, boundMax', ƒ±) )

--------------------------------------------------------------------------------

data NumSign = SignPlus | SignMinus deriving (Eq, Show)

------------------------------------------------------------

class Countable Œ± where
  count :: Œ± ‚Üí ‚Ñï

instance Countable (AtMost n a) where
  count Nil        = 0
  count (Cons _ x) = 1 + count x

------------------------------------------------------------

{- Thank you to dfeuer, redneb, leftroundabout on StackOverflow
   http://stackoverflow.com/questions/39690844/haskell-how-do-i-create-a-function-that-allows-none-one-or-two-applicatives
-}

data Nat = Z
         | S Nat
  deriving (Eq, Ord, Show)

instance Countable Nat where
  count Z     = 0
  count (S n) = 1 + count n

------------------------------------------------------------

data Natty n where Zy :: Natty 'Z
                   Sy :: Natty n -> Natty ('S n)

instance Countable (Natty n) where
  count Zy     = 0
  count (Sy n) = 1 + count n

_show ‚à∑ Natty n ‚Üí String
_show Zy     = "'Z"
_show (Sy n) = "'S " ‚óá _show n

instance Show (Natty n) where
  show z = "Natty " ‚óá _show z

instance Eq (Natty n) where
  Zy     == Zy     = ùì£
  (Sy n) == (Sy m) = n == m

instance Ord (Natty n) where
  Zy     <= _      = ùì£
  (Sy n) <= (Sy m) = n <= m

------------------------------------------------------------

data AtMost n a where Nil :: AtMost n a
                      Cons :: a -> AtMost n a -> AtMost ('S n) a

instance Eq (AtMost n a) where
  a == b = (count a) == (count b)

instance Ord (AtMost n a) where
  a <= b = (count a) <= (count b)

------------------------------------------------------------

atMost ‚à∑ Alternative f ‚áí Natty n ‚Üí f a ‚Üí f (AtMost n a)
atMost Zy _     = pure Nil
atMost (Sy n) a = (Cons ‚ä≥ a ‚äµ atMost n a) ‚à§ pure Nil

atMostOne ‚à∑ Alternative f ‚áí f a ‚Üí f (AtMost One a)
atMostOne = atMost (Sy Zy)
atMostTwo ‚à∑ Alternative f ‚áí f a ‚Üí f (AtMost Two a)
atMostTwo = atMost (Sy (Sy Zy))

type None  = 'Z
type One   = 'S None
type Two   = 'S One -- ('S 'Z)
type Three = 'S Two
type Four  = 'S Three

none ‚à∑ Natty 'Z
none = Zy

one ‚à∑ Natty ('S 'Z)
one  = Sy none

two ‚à∑ Natty ('S ('S 'Z))
two  = Sy one

three ‚à∑ Natty ('S ('S ('S 'Z)))
three  = Sy two

four ‚à∑ Natty ('S ('S ('S ('S 'Z))))
four  = Sy three

eBound ‚à∑ Show œâ ‚áí ùîº (BoundedError œâ) ŒΩ ‚Üí ŒΩ
eBound = either (error ‚àò show) id

------------------------------------------------------------

class (Unsigned ŒΩ, Integral ŒΩ) ‚áí Length Œ± ŒΩ | Œ± ‚Üí ŒΩ where
  {-| get the unsigned length of a thing; will error if the type cannot
      represent the value.  In practice, for all currently-supported types
      (Foldable, (Lazy)Text, (Lazy)ByteString); (any type whose maxBound is ‚â•
      maxBound @Int64): there will be no error. -}
  len ‚à∑ ‚àÄ Œµ Œ∑ . (AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí Œ± ‚Üí Œ∑ ŒΩ
  {-| unicode alias for `len` -}
  ‚Ñì ‚à∑ ‚àÄ Œµ Œ∑ . (AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí Œ± ‚Üí Œ∑ ŒΩ
  ‚Ñì = len

  {-| as `len`, but any error is thrown as a runtime `BoundedError` -}
  len_ ‚à∑ Show  ŒΩ ‚áí Œ± ‚Üí ŒΩ
  len_ = eBound ‚àò len
  {-| unicode alias for `len_` -}
  —â ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ŒΩ
  —â = len_

  {-| `len_`, specialized to ‚Ñï -}
  length ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ‚Ñï
  length = fromIntegral ‚àò len_

  {-| unicode alias for `length` -}
  ·ªª ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ‚Ñï
  ·ªª = length

--------------------

instance Foldable œà ‚áí Length (œà Œ±) Word64 where
  len = ƒ± ‚àò Data.Foldable.length

--------------------

instance Length ùïã Word64 where
  len    = ƒ± ‚àò Text.length

--------------------

instance Length LazyText.Text Word64 where
  len    = ƒ± ‚àò LazyText.length

--------------------

instance Length BS.ByteString Word64 where
  len = ƒ± ‚àò BS.length

--------------------

instance Length BSL.ByteString Word64 where
  len = ƒ± ‚àò BSL.length

------------------------------------------------------------


----------------------------------------

zeroOneOrTwo ‚à∑ Alternative f ‚áí f a ‚Üí f [a]
zeroOneOrTwo a = go (2 :: ‚Ñï)
  where
    go n
      | n > 0 = ((:) ‚ä≥ a ‚äµ go (n - 1)) ‚à§ pure []
      | otherwise = pure []

----------------------------------------

{-| subtract `y` from `x`, but if that would go negative, return 0 -}
natNeg ‚à∑ ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
natNeg x y = if x ‚â• y then x - y else 0

{- Standard operators - (+), (-), (*) perform modulo arithmetic; this is
   consistent with the standard library.  Where that makes no sense (e.g.,
   `(0‚à∑‚Ñï)-1`); it errors (arithmetic underflow).

   We use circled operators (‚äï), (‚äñ), (‚äó) for error-generating arithmetic.

   The triangle operators (‚®π), (‚®∫), (‚®ª) are as for the circled operators; but
   specialized to BoundedError.

   We use squared operators (‚äû), (‚äü), (‚ä†) for bounded arithmetic: things that
   would fall off the end of the line (negative, or greater than maxBound) just
   stick at the limit (that is, 0 or maxBound).  E.g., `maxBound ‚äû 2` ‚â° maxBound
-}


{- | `maxBound`, for some input type -}
mb ‚à∑ Bounded ŒΩ ‚áí ŒΩ ‚Üí ŒΩ
mb _ = maxBound

{- | Use `fromIntegral` to convert an ‚Ñ§ to an instance of the type of some other
     `Num` -}
asb ‚à∑ Num Œ± ‚áí Œ± ‚Üí ‚Ñ§ ‚Üí Œ±
asb _ z = fromIntegral z

{- | the simple binary repr of an unsigned int value; as a list of bools,
     most-significant first -}
bits ‚à∑ FiniteBits Œ≤ ‚áí Œ≤ ‚Üí [Bool]
bits x = testBit x ‚ä≥ ([(finiteBitSize x)-1,(finiteBitSize x)-2..0])

ƒ© ‚à∑ Integral Œ± ‚áí Œ± ‚Üí ‚Ñ§
ƒ© = fromIntegral @_ @‚Ñ§

(‚äï) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
                 AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äï b =
  case dropWhile (uncurry xor) $ (zip (bits a) (bits b)) of
    ((ùì£,ùì£) : _ ) ‚Üí throwUpperBoundError (typeOf a) (ƒ© a + ƒ© b) (mb a)
    _            ‚Üí return $ a + b


(‚®π) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
               MonadError (BoundedError ŒΩ) Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®π) = (‚äï)

(‚äû) ‚à∑ (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí ŒΩ
a ‚äû b = case a ‚®π b of
          ùì° c ‚Üí c
          ùìõ e ‚Üí bound e

(‚äñ) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
       ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äñ b = if b > a
        then throwLowerBoundError (typeOf a) (ƒ© a - ƒ© b)  0
        else return $ a - b

(‚®∫) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ,Integral ŒΩ,MonadError (BoundedError ŒΩ) Œ∑)‚áíŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®∫) = (‚äñ)

(‚äü) ‚à∑ (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí ŒΩ
a ‚äü b = case a ‚®∫ b of
          ùì° c ‚Üí c
          ùìõ _ ‚Üí 0

(‚äó) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
                 AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
      ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äó b = do
  let bitWidth ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±, Integral Œ≤)‚áí Œ±‚ÜíŒ≤
      bitWidth x = fromIntegral $ finiteBitSize x - countLeadingZeros x
      w = finiteBitSize a
      w‚ÇÇ = case w `divMod` 2 of
             (_,1) ‚Üí error $ —é [ "odd bit widths unsupported (got ",show w,")" ]
             (y,_) ‚Üí y

      loBits ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      loBits _ = oneBits .>>. (fromIntegral w‚ÇÇ)

      lo ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      lo x = x .&. loBits x

      hi ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      hi x = x .>>. (fromIntegral w‚ÇÇ)

      tooBig = throwUpperBoundError (typeOf a) (ƒ© a √ó ƒ© b) (mb a)
  case bitWidth a + bitWidth b ‚â∑ (1 + finiteBitSize a) of
                 GT ‚Üí tooBig
                 LT ‚Üí return $ a √ó b
                 EQ ‚Üí case over both (> loBits a) (hi a √ó lo b, hi b √ó lo a) of
                        (ùì£,_) ‚Üí tooBig
                        (_,ùì£) ‚Üí tooBig
                        (ùìï,ùìï) ‚Üí foldM (‚äï) 0 [ hi a √ó lo b .<<. w‚ÇÇ
                                            , hi b √ó lo a .<<. w‚ÇÇ
                                            , lo a √ó lo b
                                            ]

(‚®ª) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
               MonadError (BoundedError ŒΩ) Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®ª) = (‚äó)

(‚ä†) ‚à∑ (Unsigned Œ≤, Integral Œ≤, Bounded Œ≤, FiniteBits Œ≤) ‚áí Œ≤ ‚Üí Œ≤ ‚Üí Œ≤
a ‚ä† b = case a ‚äó b of
          ùìõ e -> case boundedErrorType e of
                   UpperBoundType -> ‚Öé (boundMax' a)
                   LowerBoundType -> 0
          ùì° r -> r

{-| Perform a bounded operation; compare the result to a given ‚Ñ§ equivalent;
    if the equivalent function would produce an out-of-bounds result, then
    our bounded operation should give a BoundedError; else, it should produce
    a bounded equivalent to the Integer value. -}
propOpRespectsBounds ‚à∑ (Unsigned Œ≤,Integral Œ≤,Bounded Œ≤,FiniteBits Œ≤,Show Œ≤) ‚áí
                       ( Œ≤ ‚Üí Œ≤ ‚Üí ùîº (BoundedError Œ≤) Œ≤)
                     ‚Üí (‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) ‚Üí Œ≤ ‚Üí Œ≤ ‚Üí Property
propOpRespectsBounds f g a b =
  let x = g (toInteger a) (toInteger b)
  in  if x ‚â° toInteger (asb a x)
      then (toInteger ‚ä≥ f a b) === ùì° x
      else property $ isLeft (f a b)

{-| Perform a bounded operation; compare the result to a given ‚Ñ§ equivalent; if
    the equivalent function would produce an out-of-bounds result, then our
    bounded operation should give the bounded equivalent; else the bounded
    equivalent to the Integer value. -}
propOpBounded ‚à∑ (Unsigned Œ≤,Integral Œ≤,Bounded Œ≤,FiniteBits Œ≤,Show Œ≤) ‚áí
                (Œ≤ ‚Üí Œ≤ ‚Üí Œ≤)
              ‚Üí (‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) ‚Üí Œ≤ ‚Üí Œ≤ ‚Üí ùîπ
propOpBounded f g a b =
  let x = g (toInteger a) (toInteger b)
      r = f a b
  in  case x ‚â∂ (ùìô 0, boundMax a) of
        LT -> r == 0
        EQ -> r == fromInteger x
        GT -> r == ‚Öé (boundMax' a)

{-| split an integer into a natural number and a `NumSign` -}
unNegate ‚à∑ ‚Ñ§ ‚Üí (NumSign,‚Ñï)
unNegate n | n < 0     = (SignMinus, GHC.Real.fromIntegral $ abs n)
           | otherwise = (SignPlus,  GHC.Real.fromIntegral n)

----------------------------------------

class (Ord Œ±, Num Œ±) ‚áí Abs Œ± where
  {-| when invoking `abs`, this is the target type -}
  type Abs' Œ± ‚à∑ Type
  {-| abs, but correcting the type -}
  abs ‚à∑ Œ± ‚Üí Abs' Œ±
  {-| like `Prelude.abs`, maintains the type -}
  abs' ‚à∑ Œ± ‚Üí Œ±
  {-| like `abs'`, also return the sign of the original -}
  abs'' ‚à∑ Œ± ‚Üí (NumSign,Abs' Œ±)
  abs'' n | n < 0     = (SignMinus, abs n)
          | otherwise = (SignPlus, abs n)

instance Abs ‚Ñ§ where
  type Abs' ‚Ñ§ = ‚Ñï
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs I64 where
  type Abs' I64 = Word64
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int64 where
  type Abs' Int64 = Word64
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int32 where
  type Abs' Int32 = Word32
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int16 where
  type Abs' Int16 = Word16
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int8 where
  type Abs' Int8 = Word8
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance (Integral Œ±, Abs Œ±, Integral (Abs' Œ±)) ‚áí Abs (Ratio Œ±) where
  type Abs' (Ratio Œ±) = Ratio (Abs' Œ±)
  abs a = abs (numerator a) √∑ abs (denominator a)
  abs' = Prelude.abs

------------------------------------------------------------

type RatioN = Ratio ‚Ñï

{-| convert a `Real` into fraction (`RatioN`), and a `NumSign` -}
toRatioN ‚à∑ Real Œ± ‚áí Œ± ‚Üí (NumSign, RatioN)
toRatioN (toRational ‚Üí a) = abs'' a

-- that's all, folks! ----------------------------------------------------------
