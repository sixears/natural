{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE UnicodeSyntax              #-}

module Natural
  ( AtMost(Cons, Nil)
  , Countable(count)
  , Four
  , I64
  , Length(len, len_, length)
  , Nat(S, Z)
  , Natty(Sy, Zy)
  , None
  , NumSign(..)
  , One
  , Replicate(replicate, replicate_)
  , Three
  , Two
  , Unsigned(boundMax, boundMax', fromI, fromI0, fromI', fromI_, ƒ±, ·ªã, …®)
  , ‚Ñï
  , abs
  , allEnum
  , atMost
  , atMostOne
  , atMostTwo
  , four
  , fromEnum
  , fromEnum_
  , natNeg
  , none
  , one
  , propOpRespectsBounds
  , three
  , toEnum
  , toEnum'
  , toEnum_
  , two
  , unNegate
  , zeroOneOrTwo
  , (‚äï)
  , (‚äñ)
  , (‚®π)
  , (‚®∫)
  , (‚®ª)
  ) where

import Debug.Trace ( traceShow )

import Base0T hiding ( abs, (√∑), (‚äï) )
import Base0T qualified

import GHC.Enum qualified
import GHC.Num qualified
import GHC.Real qualified

import GHC.Enum  ( Bounded, maxBound )
import GHC.Float ( Double, logBase )
import GHC.Num   ( Num )
import GHC.Real  ( Integral, Real, divMod, fromIntegral, toRational )

-- base --------------------------------

import Data.Foldable qualified
import Data.List qualified

import Control.Applicative ( Alternative )
import Data.Bits           ( FiniteBits(finiteBitSize), countLeadingZeros,
                             oneBits, testBit, xor, (.&.), (.<<.), (.>>.) )
import Data.Bool           ( Bool(True) )
import Data.Either         ( isLeft )
import Data.Foldable       ( Foldable, elem )
import Data.Function       ( flip )
import Data.Int            ( Int16, Int32, Int64, Int8 )
import Data.Kind           ( Type )
import Data.List           ( dropWhile, zip )
import Data.Ord            ( Ordering(EQ, GT, LT), compare )
import Data.Ratio          ( Ratio, denominator, numerator, (%) )
import Data.Tuple          ( uncurry )
import Data.Typeable       ( typeOf )
import GHC.Exts            ( Int )
import Prelude             ( Enum, error )

-- base-unicode-symbols ----------------

import Prelude.Unicode ( (√ó) )

-- bytestring --------------------------

import Data.ByteString      qualified as BS
import Data.ByteString.Lazy qualified as BSL

-- lens --------------------------------

import Control.Lens.Setter    ( over )
import Control.Lens.Traversal ( both )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative ( (‚à§), (‚äµ) )
import Data.MoreUnicode.Bool        ( ùîπ, pattern ùï±, pattern ùïø )
import Data.MoreUnicode.Either      ( ùîº, pattern ùï∑, pattern ùïΩ )
import Data.MoreUnicode.Functor     ( (‚ä≥), (‚©∫) )
import Data.MoreUnicode.Maybe       ( ùïÑ, pattern ùïµ, pattern ùïπ )
import Data.MoreUnicode.Monoid      ( —é )
import Data.MoreUnicode.Semigroup   ( (‚óá) )
import Data.MoreUnicode.Text        ( ùïã )

-- tasty-quickcheck --------------------

import Test.Tasty.QuickCheck ( Property, property, (===) )

-- text --------------------------------

import Data.Text      qualified as Text
import Data.Text.Lazy qualified as LazyText

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Natural.BoundedError ( AsBoundedError, BoundedError, bound,
                              throwLowerBoundError, throwUpperBoundError )

--------------------------------------------------------------------------------

data NumSign = SignPlus | SignMinus deriving (Eq, Show)

------------------------------------------------------------

class Countable Œ± where
  count :: Œ± ‚Üí ‚Ñï

instance Countable (AtMost n a) where
  count Nil        = 0
  count (Cons _ x) = 1 + count x

------------------------------------------------------------

{- Thank you to dfeuer, redneb, leftroundabout on StackOverflow
   http://stackoverflow.com/questions/39690844/haskell-how-do-i-create-a-function-that-allows-none-one-or-two-applicatives
-}

data Nat = Z
         | S Nat
  deriving (Eq, Ord, Show)

instance Countable Nat where
  count Z     = 0
  count (S n) = 1 + count n

------------------------------------------------------------

data Natty n where Zy :: Natty 'Z
                   Sy :: Natty n -> Natty ('S n)

instance Countable (Natty n) where
  count Zy     = 0
  count (Sy n) = 1 + count n

_show ‚à∑ Natty n ‚Üí String
_show Zy     = "'Z"
_show (Sy n) = "'S " ‚óá _show n

instance Show (Natty n) where
  show z = "Natty " ‚óá _show z

instance Eq (Natty n) where
  Zy     == Zy     = True
{-
    ‚Ä¢ Couldn't match type ‚Äò'Z‚Äô with ‚Äò'S n1‚Äô
      Inaccessible code in
        a pattern with constructor:
          Sy :: forall (n :: Nat). Natty n -> Natty ('S n),
        in an equation for ‚Äò==‚Äô
    ‚Ä¢ In the pattern: Sy _
      In an equation for ‚Äò==‚Äô: Zy == (Sy _) = False
      In the instance declaration for ‚ÄòEq (Natty n)‚Äô

  Zy     == (Sy _) = False
-}
{-
    ‚Ä¢ Couldn't match type ‚Äò'S n1‚Äô with ‚Äò'Z‚Äô
      Inaccessible code in
        a pattern with constructor: Zy :: Natty 'Z, in an equation for ‚Äò==‚Äô
    ‚Ä¢ In the pattern: Zy
      In an equation for ‚Äò==‚Äô: (Sy _) == Zy = False
      In the instance declaration for ‚ÄòEq (Natty n)‚Äô

  (Sy _) == Zy     = False
-}
  (Sy n) == (Sy m) = n == m

instance Ord (Natty n) where
  Zy     <= _      = True
{-
    ‚Ä¢ Couldn't match type ‚Äò'S n1‚Äô with ‚Äò'Z‚Äô
      Inaccessible code in
        a pattern with constructor: Zy :: Natty 'Z, in an equation for ‚Äò<=‚Äô
    ‚Ä¢ In the pattern: Zy
      In an equation for ‚Äò<=‚Äô: (Sy _) <= Zy = False
      In the instance declaration for ‚ÄòOrd (Natty n)‚Äô

  (Sy _) <= Zy     = False
-}
  (Sy n) <= (Sy m) = n <= m

------------------------------------------------------------

data AtMost n a where Nil :: AtMost n a
                      Cons :: a -> AtMost n a -> AtMost ('S n) a

instance Eq (AtMost n a) where
  a == b = (count a) == (count b)

instance Ord (AtMost n a) where
  a <= b = (count a) <= (count b)

------------------------------------------------------------

atMost ‚à∑ Alternative f ‚áí Natty n ‚Üí f a ‚Üí f (AtMost n a)
atMost Zy _     = pure Nil
atMost (Sy n) a = (Cons ‚ä≥ a ‚äµ atMost n a) ‚à§ pure Nil

atMostOne ‚à∑ Alternative f ‚áí f a ‚Üí f (AtMost One a)
atMostOne = atMost (Sy Zy)
atMostTwo ‚à∑ Alternative f ‚áí f a ‚Üí f (AtMost Two a)
atMostTwo = atMost (Sy (Sy Zy))

type None  = 'Z
type One   = 'S None
type Two   = 'S One -- ('S 'Z)
type Three = 'S Two
type Four  = 'S Three

none ‚à∑ Natty 'Z
none = Zy

one ‚à∑ Natty ('S 'Z)
one  = Sy none

two ‚à∑ Natty ('S ('S 'Z))
two  = Sy one

three ‚à∑ Natty ('S ('S ('S 'Z)))
three  = Sy two

four ‚à∑ Natty ('S ('S ('S ('S 'Z))))
four  = Sy three

eBound ‚à∑ Show œâ ‚áí ùîº (BoundedError œâ) ŒΩ ‚Üí ŒΩ
eBound = either (error ‚àò show) id

------------------------------------------------------------

class Typeable ŒΩ ‚áí Unsigned ŒΩ where
  {-| like `maxBound`, but ùïπ if no upper bound -}
  boundMax' ‚à∑ Integral ŒΩ ‚áí ŒΩ ‚Üí ùïÑ ŒΩ
  {-| like `maxBound`, but as an ‚Ñ§, or ùïπ if no upper bound -}
  boundMax ‚à∑ Integral ŒΩ ‚áí ŒΩ ‚Üí ùïÑ ‚Ñ§
  boundMax = toInteger ‚©∫ boundMax'

  {-| convert from a general integral type, throwing as necessary -}
  fromI ‚à∑ ‚àÄ Œµ Œ≤ Œ∑ . (Integral ŒΩ, Integral Œ≤, AsBoundedError Œµ ŒΩ,MonadError Œµ Œ∑)‚áí
          Œ≤ ‚Üí Œ∑ ŒΩ
  -- we cannot do this as a set of guards (e.g., `fromI i | i < 0 = ...`),
  -- because we need to pre-construct (lexically) the value i' to take its
  -- `typeOf`.  I tried implying the type from the return, etc., and using a
  -- proxy, but GHC can't handle the type inference there
  fromI i = let i' = fromIntegral i
            in  if i < 0
                then throwLowerBoundError (typeOf i') (toInteger i) 0
                else case boundMax' i' of
                       ùïπ ‚Üí return i'
                       ùïµ m ‚Üí if toInteger i > toInteger m
                             then throwUpperBoundError (typeOf i')
                                                       (toInteger i) m
                             else return i'

  ƒ± ‚à∑ ‚àÄ Œµ Œ≤ Œ∑ . (Integral ŒΩ, Integral Œ≤, AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
      Œ≤ ‚Üí Œ∑ ŒΩ
  ƒ± = fromI

  {-| convert from a general integral type, return  0 for negative values -}
  fromI0  ‚à∑ ‚àÄ Œµ Œ≤ Œ∑ . (Integral ŒΩ,Integral Œ≤,AsBoundedError Œµ ŒΩ,MonadError Œµ Œ∑)‚áí
            Œ≤ ‚Üí Œ∑ ŒΩ
  fromI0 i | i < 0     = return 0
           | otherwise = fromI i
  ·ªã ‚à∑ ‚àÄ Œµ Œ≤ Œ∑ . (Integral ŒΩ, Integral Œ≤, AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
      Œ≤ ‚Üí Œ∑ ŒΩ
  ·ªã= fromI0

  {-| convert from a general integral type, return 0 / maxBound for out-of-bound
      values -}
  fromI'  ‚à∑ (Integral ŒΩ, Integral Œ≤) ‚áí Œ≤ ‚Üí ŒΩ
  fromI' i | i < 0     = 0
           | otherwise = let i' = fromIntegral i
                         in  case boundMax i' of
                               ùïπ   ‚Üí i'
                               ùïµ m ‚Üí if toInteger i > m
                                     then fromIntegral m
                                     else i'

  {-| convert from a general integral type, error as necessary -}
  fromI_  ‚à∑ (Integral ŒΩ, Integral Œ≤, Show ŒΩ) ‚áí Œ≤ ‚Üí ŒΩ
  fromI_ = eBound ‚àò fromI
  …® ‚à∑ (Integral ŒΩ, Show ŒΩ, Integral Œ≤) ‚áí Œ≤ ‚Üí ŒΩ
  …® = fromI_

--------------------

instance Unsigned ‚Ñï where
  boundMax' _ = ùïπ

--------------------

instance Unsigned Word8 where
  boundMax' _ = ùïµ $ maxBound @Word8

instance Unsigned Word16 where
  boundMax' _ = ùïµ $ maxBound @Word16

instance Unsigned Word32 where
  boundMax' _ = ùïµ $ maxBound @Word32

instance Unsigned Word64 where
  boundMax' _ = ùïµ $ maxBound @Word64

------------------------------------------------------------

{-| Like Int64, but unsigned.  Notably, maxBound @I64 ‚â° maxBound @Int64;
    which is maxBound @64 √∑ 2 -}
newtype I64 = I64 Word64
  deriving newtype (Enum, Eq, Integral, Num, Ord, Real, Show)

instance Unsigned I64 where
  boundMax' _ = ùïµ $ fromIntegral (maxBound @Int64)

instance Bounded I64 where
  minBound = 0
  maxBound = fromIntegral $ maxBound @Int64

i64ToInt ‚à∑ I64 ‚Üí Int
i64ToInt (I64 w) = fromIntegral w

------------------------------------------------------------

class (Unsigned ŒΩ, Integral ŒΩ) ‚áí Length Œ± ŒΩ | Œ± ‚Üí ŒΩ where
  {-| get the unsigned length of a thing; will error if the type cannot
      represent the value.  In practice, for all currently-supported types
      (Foldable, (Lazy)Text, (Lazy)ByteString); (any type whose maxBound is ‚â•
      maxBound @Int64): there will be no error. -}
  len ‚à∑ ‚àÄ Œµ Œ∑ . (AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí Œ± ‚Üí Œ∑ ŒΩ
  {-| unicode alias for `len` -}
  ‚Ñì ‚à∑ ‚àÄ Œµ Œ∑ . (AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí Œ± ‚Üí Œ∑ ŒΩ
  ‚Ñì = len

  {-| as `len`, but any error is thrown as a runtime `BoundedError` -}
  len_ ‚à∑ Show  ŒΩ ‚áí Œ± ‚Üí ŒΩ
  len_ = eBound ‚àò len
  {-| unicode alias for `len_` -}
  —â ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ŒΩ
  —â = len_

  {-| `len_`, specialized to ‚Ñï -}
  length ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ‚Ñï
  length = fromIntegral ‚àò len_

  {-| unicode alias for `length` -}
  ·ªª ‚à∑ Show ŒΩ ‚áí Œ± ‚Üí ‚Ñï
  ·ªª = length

--------------------

instance Foldable œà ‚áí Length (œà Œ±) Word64 where
  len = ƒ± ‚àò Data.Foldable.length

--------------------

instance Length ùïã Word64 where
  len    = ƒ± ‚àò Text.length

--------------------

instance Length LazyText.Text Word64 where
  len    = ƒ± ‚àò LazyText.length

--------------------

instance Length BS.ByteString Word64 where
  len = ƒ± ‚àò BS.length

--------------------

instance Length BSL.ByteString Word64 where
  len = ƒ± ‚àò BSL.length

------------------------------------------------------------

class Replicate Œ± ŒΩ | Œ± -> ŒΩ where
  {-| build an instance of type `Œ±` from an unsigned number of `Item Œ±`.
      In practice, for all currently-supported types
      ([Œ≤], (Lazy)Text, (Lazy)ByteString); (any type whose maxBound is ‚â•
      maxBound @Int64): there will be no error.
   -}
  replicate ‚à∑ ‚àÄ Œµ Œ∑.(Unsigned ŒΩ,Integral ŒΩ,AsBoundedError Œµ ŒΩ,MonadError Œµ Œ∑)‚áí
              ŒΩ ‚Üí Item Œ± ‚Üí Œ∑ Œ±

  -- in practice, there will be no error with anything that fits into an I64,
  -- that is, [0,maxBound @Int64]
  {-| as `replicate`, but any error is thrown as a runtime `BoundedError` -}
  replicate_ ‚à∑ (Unsigned ŒΩ, Integral ŒΩ, Show ŒΩ) ‚áí ŒΩ ‚Üí Item Œ± ‚Üí Œ±
  replicate_ n = eBound ‚àò replicate n

instance Replicate [Œ±] I64 where
  replicate n c = flip Data.List.replicate c ‚àò fromIntegral ‚ä≥ ƒ± n

instance Replicate ùïã I64 where
  replicate n c = flip Text.replicate (Text.singleton c) ‚àò fromIntegral ‚ä≥ ƒ± n

instance Replicate LazyText.Text I64 where
  replicate n c =
    flip LazyText.replicate (LazyText.singleton c) ‚àò fromIntegral ‚ä≥ ƒ± n

instance Replicate BS.ByteString I64 where
  replicate n c = flip BS.replicate c ‚àò fromIntegral ‚ä≥ ƒ± n

instance Replicate BSL.ByteString I64 where
  replicate n c =
    flip BSL.replicate c ‚àò fromIntegral ‚ä≥ ƒ± n

----------------------------------------

fromEnum ‚à∑ ‚àÄ Œµ Œ± ŒΩ Œ∑ .
           (Unsigned ŒΩ,Integral ŒΩ,AsBoundedError Œµ ŒΩ,MonadError Œµ Œ∑,Enum Œ±)‚áí
           Œ± ‚Üí Œ∑ ŒΩ
fromEnum = ƒ± ‚àò GHC.Enum.fromEnum

--------------------

fromEnum_ ‚à∑ ‚àÄ Œ± ŒΩ . (Unsigned ŒΩ, Integral ŒΩ, Enum Œ±, Show ŒΩ) ‚áí Œ± ‚Üí ŒΩ
fromEnum_ = …® ‚àò GHC.Enum.fromEnum

----------------------------------------

toEnum ‚à∑ ‚àÄ Œµ ŒΩ Œ± Œ∑ .
         (Bounded Œ±, Enum Œ±, Unsigned ŒΩ, Integral ŒΩ,
          AsBoundedError Œµ I64, MonadError Œµ Œ∑)‚áí
         ŒΩ ‚Üí Œ∑ Œ±
toEnum input = do
  result ‚Üê (GHC.Enum.toEnum ‚àò i64ToInt ‚©∫ ƒ±) input
  let max_result = maxBound
      max_int = fromEnum_ max_result -- max input value for this enum
  if ùïø
  then (if fromIntegral input > max_int
        then throwUpperBoundError (typeOf I64) (fromIntegral input) max_int
        else return result)
  else return max_result -- never used, just forces the type for max_result

--------------------

{- | `toEnum`, but for not (upper-)bounded types.  If you use this for
     a type with an upper bound, hilarity and/or sadness may ensue.

     `GHC.Enum.toEnum ‚à∑ Int -> Œ±`; that `Int` is `Int64` in practice‚Ä¶
     so in practice, enums (or at least toEnum) is restricted to `Int64`:
     this is necessarily reflected in the type of `BoundedError`.
-}
toEnum' ‚à∑ ‚àÄ Œµ ŒΩ Œ± Œ∑ .
         (Enum Œ±, Unsigned ŒΩ, Integral ŒΩ,
          AsBoundedError Œµ I64, MonadError Œµ Œ∑)‚áí
         ŒΩ ‚Üí Œ∑ Œ±
toEnum' = GHC.Enum.toEnum ‚àò i64ToInt ‚©∫ ƒ±

--------------------

toEnum_ ‚à∑ ‚àÄ ŒΩ Œ± . (Unsigned ŒΩ, Integral ŒΩ, Enum Œ±) ‚áí ŒΩ ‚Üí Œ±
toEnum_ = GHC.Enum.toEnum ‚àò i64ToInt ‚àò …®

----------------------------------------

allEnum ‚à∑ Enum Œ± ‚áí [Œ±]
allEnum = GHC.Enum.enumFrom (toEnum_ @‚Ñï 0)

----------------------------------------

zeroOneOrTwo ‚à∑ Alternative f ‚áí f a ‚Üí f [a]
zeroOneOrTwo a = go (2 :: ‚Ñï)
  where
    go n
      | n > 0 = ((:) ‚ä≥ a ‚äµ go (n - 1)) ‚à§ pure []
      | otherwise = pure []

----------------------------------------

{-| subtract `y` from `x`, but if that would go negative, return 0 -}
natNeg ‚à∑ ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
natNeg x y = if x ‚â• y then x - y else 0

{- Standard operators - (+), (-), (*) perform modulo arithmetic; this is
   consistent with the standard library.  Where that makes no sense (e.g.,
   `(0‚à∑‚Ñï)-1`); it errors (arithmetic underflow).

   We use circled operators (‚äï), (‚äñ), (‚äó) for error-generating arithmetic.

   The triangle operators (‚®π), (‚®∫), (‚®ª) are as for the circled operators; but
   specialized to BoundedError.

   We use squared operators (‚äû), (‚äü), (‚ä†) for bounded arithmetic: things that
   would fall off the end of the line (negative, or greater than maxBound) just
   stick at the limit (that is, 0 or maxBound).  E.g., `maxBound ‚äû 2` ‚â° maxBound
-}


{- | `maxBound`, for some input type -}
mb ‚à∑ Bounded ŒΩ ‚áí ŒΩ ‚Üí ŒΩ
mb _ = maxBound

{- | Use `fromIntegral` to convert an ‚Ñ§ to an instance of the type of some other
     `Num` -}
asb ‚à∑ Num Œ± ‚áí Œ± ‚Üí ‚Ñ§ ‚Üí Œ±
asb _ z = fromIntegral z

{- | the simple binary repr of an unsigned int value; as a list of bools,
     most-significant first -}
bits ‚à∑ FiniteBits Œ≤ ‚áí Œ≤ ‚Üí [Bool]
bits x = testBit x ‚ä≥ ([(finiteBitSize x)-1,(finiteBitSize x)-2..0])

ƒ© ‚à∑ Integral Œ± ‚áí Œ± ‚Üí ‚Ñ§
ƒ© = fromIntegral @_ @‚Ñ§

(‚äï) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
                 AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äï b =
  case dropWhile (uncurry xor) $ (zip (bits a) (bits b)) of
    ((ùïø,ùïø) : _ ) ‚Üí throwUpperBoundError (typeOf a) (ƒ© a + ƒ© b) (mb a)
    _            ‚Üí return $ a + b


(‚®π) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
               MonadError (BoundedError ŒΩ) Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®π) = (‚äï)

(‚äû) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí ŒΩ
a ‚äû b = case a ‚®π b of
          ùïΩ c ‚Üí c
          ùï∑ e ‚Üí bound e

(‚äñ) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
       ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äñ b = if b > a
        then throwLowerBoundError (typeOf a) (ƒ© a - ƒ© b)  0
        else return $ a - b

(‚®∫) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ,Integral ŒΩ,MonadError (BoundedError ŒΩ) Œ∑)‚áíŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®∫) = (‚äñ)

(‚äó) ‚à∑ ‚àÄ Œµ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
                 AsBoundedError Œµ ŒΩ, MonadError Œµ Œ∑) ‚áí
      ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
a ‚äó b = do
  let bitWidth ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±, Integral Œ≤)‚áí Œ±‚ÜíŒ≤
      bitWidth x = fromIntegral $ finiteBitSize x - countLeadingZeros x
      w = finiteBitSize a
      w‚ÇÇ = case w `divMod` 2 of
             (_,1) ‚Üí error $ —é [ "odd bit widths unsupported (got ",show w,")" ]
             (y,_) ‚Üí y

      loBits ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      loBits _ = oneBits .>>. (fromIntegral w‚ÇÇ)

      lo ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      lo x = x .&. loBits x

      hi ‚à∑ (Integral Œ±, FiniteBits Œ±, Unsigned Œ±) ‚áí Œ± ‚Üí Œ±
      hi x = x .>>. (fromIntegral w‚ÇÇ)

      tooBig = throwUpperBoundError (typeOf a) (ƒ© a √ó ƒ© b) (mb a)
  case bitWidth a + bitWidth b ‚â∑ (1 + finiteBitSize a) of
                 GT ‚Üí tooBig
                 LT ‚Üí return $ a √ó b
                 EQ ‚Üí case over both (> loBits a) (hi a √ó lo b, hi b √ó lo a) of
                        (ùïø,_) ‚Üí tooBig
                        (_,ùïø) ‚Üí tooBig
                        (ùï±,ùï±) ‚Üí foldM (‚äï) 0 [ hi a √ó lo b .<<. w‚ÇÇ
                                            , hi b √ó lo a .<<. w‚ÇÇ
                                            , lo a √ó lo b
                                            ]

(‚®ª) ‚à∑ ‚àÄ ŒΩ Œ∑ . (Unsigned ŒΩ, Integral ŒΩ, Bounded ŒΩ, FiniteBits ŒΩ,
               MonadError (BoundedError ŒΩ) Œ∑) ‚áí ŒΩ ‚Üí ŒΩ ‚Üí Œ∑ ŒΩ
(‚®ª) = (‚äó)

{-| Perform a bounded operation; compare the result to a given ‚Ñ§ equivalent;
    if the equivalent function would produce an out-of-bounds result, then
    our bounded operation should give a BoundedError; else, it should produce
    a bounded equivalent to the Integer value. -}
{-
propOpRespectsBounds ‚à∑ (Unsigned Œ±,Integral Œ±,Bounded Œ±,FiniteBits Œ±,Show Œ±) ‚áí
                       (‚àÄ Œ≤ . (Unsigned Œ≤,Integral Œ≤,Bounded Œ≤,FiniteBits Œ≤) ‚áí
                         Œ≤ ‚Üí Œ≤ ‚Üí ùîº (BoundedError Œ±) Œ≤)
                     ‚Üí (‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) ‚Üí Œ± ‚Üí Œ± ‚Üí Property
-}
propOpRespectsBounds ‚à∑ (Unsigned Œ≤,Integral Œ≤,Bounded Œ≤,FiniteBits Œ≤,Show Œ≤) ‚áí
                       ( Œ≤ ‚Üí Œ≤ ‚Üí ùîº (BoundedError Œ≤) Œ≤)
                     ‚Üí (‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) ‚Üí Œ≤ ‚Üí Œ≤ ‚Üí Property
propOpRespectsBounds f g a b =
  let x = g (toInteger a) (toInteger b)
  in  if x ‚â° toInteger (asb a x)
      then (toInteger ‚ä≥ f a b) === ùïΩ x
      else property $ isLeft (f a b)

{-| split an integer into a natural number and a `NumSign` -}
unNegate ‚à∑ ‚Ñ§ ‚Üí (NumSign,‚Ñï)
unNegate n | n < 0     = (SignMinus, GHC.Real.fromIntegral $ abs n)
           | otherwise = (SignPlus,  GHC.Real.fromIntegral n)

----------------------------------------

type RatioN = Ratio ‚Ñï

class (Ord Œ±, Num Œ±) ‚áí Abs Œ± where
  type Abs' Œ± ‚à∑ Type
  abs ‚à∑ Œ± ‚Üí Abs' Œ±
  abs' ‚à∑ Œ± ‚Üí Œ±
  abs'' ‚à∑ Œ± ‚Üí (NumSign,Abs' Œ±)
  abs'' n | n < 0     = (SignMinus, abs n)
         | otherwise = (SignPlus, abs n)

instance Abs ‚Ñ§ where
  type Abs' ‚Ñ§ = ‚Ñï
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int64 where
  type Abs' Int64 = Word64
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int32 where
  type Abs' Int32 = Word32
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int16 where
  type Abs' Int16 = Word16
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance Abs Int8 where
  type Abs' Int8 = Word8
  abs = fromIntegral ‚àò Base0T.abs
  abs' = Base0T.abs

instance (Integral Œ±, Abs Œ±, Integral (Abs' Œ±)) ‚áí Abs (Ratio Œ±) where
  type Abs' (Ratio Œ±) = Ratio (Abs' Œ±)
  abs a = abs (numerator a) √∑ abs (denominator a)

toRatioN ‚à∑ Real Œ± ‚áí Œ± ‚Üí (NumSign, RatioN)
toRatioN (toRational ‚Üí a) = abs'' a

{-
class Unsigned Œ≤ ‚áí Length Œ± Œ≤ | Œ± ‚Üí Œ≤ where
  length    ‚à∑ Œ± ‚Üí Œ≤
  drop      ‚à∑ Œ≤¬†‚Üí Œ± ‚Üí Œ±
  take      ‚à∑ Œ≤¬†‚Üí Œ± ‚Üí Œ±

instance Length ùïã Word64 where
  length    = fromIntegral ‚àò Text.length
  drop      = Text.drop ‚àò fromIntegral
  take      = Text.take ‚àò fromIntegral

instance Length LT.Text Word64 where
  length = fromIntegral ‚àò LT.length
  drop   = LT.drop ‚àò fromIntegral
  take   = LT.take ‚àò fromIntegral

-}
{-
instance Length ByteString where
  length = fromIntegral ‚àò BS.length

instance Length LBS.ByteString where
  length = fromIntegral ‚àò LBS.length

instance Length BS8.ByteString where
  length = fromIntegral ‚àò BS8.length

instance Length LBS8.ByteString where
  length = fromIntegral ‚àò LBS8.length
-}

{-
class While Œ± where
  dropWhile ‚à∑ (Item Œ± ‚Üí ùîπ) ‚Üí Œ± ‚Üí Œ±
  takeWhile ‚à∑ (Item Œ± ‚Üí ùîπ) ‚Üí Œ± ‚Üí Œ±

instance While [Œ±] where
  dropWhile = Data.List.dropWhile
  takeWhile = Data.List.takeWhile

instance While ùïã where
  dropWhile = Text.dropWhile
  takeWhile = Text.takeWhile

instance While LT.Text where
  dropWhile = LT.dropWhile
  takeWhile = LT.takeWhile
-}

-- ‚Ä¶ and ByteStrings ‚Ä¶

”ø ‚à∑ Printable Œµ ‚áí ùîº Œµ Œ± ‚Üí Œ±
”ø = \ case ùï∑ e ‚Üí error (toString e); ùïΩ r ‚Üí r

‚µ• ‚à∑ Printable Œµ ‚áí ùîº Œµ Œ± ‚Üí Œ±
‚µ• = \ case ùï∑ e ‚Üí error (toString e); ùïΩ r ‚Üí r

infix 4 ‚â∑
-- (‚â∑) ‚à∑ Ord Œ± ‚áí Œ± ‚Üí Œ± ‚Üí Ordering
(‚â∑) = compare

class Member Œ± where
  type MemberItem Œ± ‚à∑ Type

  (‚àà) ‚à∑ Eq (MemberItem Œ±) ‚áí MemberItem Œ± ‚Üí Œ± ‚Üí ùîπ

instance Foldable œà ‚áí Member (œà Œ≤) where
  type MemberItem (œà Œ≤) = Œ≤
  (‚àà) = elem

(√∑) ‚à∑ Integral Œ± ‚áí Œ± ‚Üí Œ± ‚Üí Ratio Œ±
(√∑) = (%)

-- that's all, folks! ----------------------------------------------------------
